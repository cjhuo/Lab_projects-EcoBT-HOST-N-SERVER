<!doctype html><title></title>
<link type="text/css" href="{{ static_url("css/main.css") }}" rel="stylesheet" />
<script language="javascript" type="text/javascript" src="{{ static_url("js/three/three.min.js") }}"></script>
<script language="javascript" type="text/javascript" src="{{ static_url("js/three/Stats.js") }}"></script>
<script src="{{ static_url("js/three/helvetiker_regular.typeface.js") }}"></script>

<body>
<div align="center"><br>
<input type="radio" name="group1" value="ECG node #1" checked> ECG node #1<br>
</div>
<script>

var container, stats;

var camera, scene, renderer;

var cube, plane;

var targetRotation = 0;
var targetRotationOnMouseDown = 0;


var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

var parent;

init();
animate();
setInterval(function(){
	render();
}, 1000);

function init() {

	container = document.createElement( 'div' );
	document.body.appendChild( container );
	
	var info = document.createElement( 'div' );
	info.style.position = 'absolute';
	info.style.top = '100px';
	info.style.width = '100%';
	info.style.textAlign = 'center';
	info.innerHTML = "<h1>Simulator of the sensor's movement</h1>";
	container.appendChild( info );

	camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
	camera.position.y = 150;
	camera.position.z = 500;

	scene = new THREE.Scene();

	// Cube

	var materials = [];

	for ( var i = 0; i < 6; i ++ ) {

		materials.push( new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ) );

	}

	cube = new THREE.Mesh( new THREE.CubeGeometry( 200, 50, 100, 1, 1, 1, materials ), new THREE.MeshFaceMaterial() );
	cube.position.y = 150;
	cube.rotation.y = 0.1;
	//scene.add( cube );
	
	// Get text from hash

	var theText = "ECG node #1";

	var hash = document.location.hash.substr( 1 );

	if ( hash.length !== 0 ) {

		theText = hash;

	}

	var text3d = new THREE.TextGeometry( theText, {

		size: 20,
		height: 0,
		curveSegments: 2,
		font: "helvetiker"

	});

	text3d.computeBoundingBox();
	var centerOffset = -0.5 * ( text3d.boundingBox.max.x - text3d.boundingBox.min.x );

	var textMaterial = new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, overdraw: true } );
	text = new THREE.Mesh( text3d, textMaterial );

	text.position.x = centerOffset;
	text.position.y = 200;
	text.position.z = 0;

	text.rotation.x = 0.1;
	//text.rotation.y = 0;

	parent = new THREE.Object3D();
	
	parent.add( cube );
	parent.add( text );
	scene.add( parent );


	renderer = new THREE.CanvasRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );

	container.appendChild( renderer.domElement );

	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	container.appendChild( stats.domElement );

	window.addEventListener( 'resize', onWindowResize, false );
	
	//render();
	renderer.render( scene, camera );

}

function onWindowResize() {

	windowHalfX = window.innerWidth / 2;
	windowHalfY = window.innerHeight / 2;

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );

}



//

function animate() {

	requestAnimationFrame( animate );

	//render();
	stats.update();

}

function render() {

	parent.rotation.y += (Math.random()-0.5)*0.1;
	parent.rotation.x += (Math.random()-0.5)*0.3;
	renderer.render( scene, camera );

}

</script>

</body>



